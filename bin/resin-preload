#!/usr/bin/env node

'use strict'

const Docker = require('dockerode')
const preload = require('..')
const info = require('../package.json')
const Promise = require('bluebird')
const streamToPromise = require('stream-to-promise')
const resinSdk = require('resin-sdk')
const tmp = Promise.promisifyAll(require('tmp'))
const visuals = require('resin-cli-visuals')

const TERMINATED_BY_CTRL_C = 130

const docker = new Docker({Promise})

tmp.setGracefulCleanup()

const USAGE = `
  Usage: ${info.name} [options]

  Options:

    --app            Application ID (required)
    --img            Disk image to preload into (required)
    --api-token      API token (required, or api-key)
    --api-key        API key (required, or api-token)
    --commit         Application commit to preload (default: latest)
    --api-host       API host (default: "https://api.resin.io")
    --registry       Image registry host (default: "registry2.resin.io")
    --splash-image   PNG Image for custom splash screen

    --dont-detect-flasher-type-images Disables the flasher type images detection: treats all images as non flasher types
    --dont-check-device-type          Disables check for matching device types in image and application

    --help, -h       Display ${info.name} usage
    --version, -v    Display ${info.name} version

  Environment variables:

    The following option flags can also be set
    via the corresponding environment variables:

    --app                               APP_ID
    --img                               IMAGE
    --api-token                         API_TOKEN
    --api-key                           API_KEY
    --commit                            COMMIT
    --api-host                          API_HOST
    --registry                          REGISTRY_HOST
    --splash-image                      SPLASH_IMAGE
    --dont-detect-flasher-type-images   DONT_DETECT_FLASHER_TYPE_IMAGES
    --dont-check-device-type            DONT_CHECK_DEVICE_TYPE

  Example:

    ${info.name} --app 123456 --api-token "xxxx..." --img /path/to/resin-os.img
`

const inspect = (value) => {
  return require('util').inspect(value, {
    colors: process.stdout.isTTY
  })
}

const showError = (error, details, report) => {
  let message = !details ? `\n[ERROR] ${error.message}` : `\n${inspect(error)}`

  if (report) {
    message += '\n\n'
    message += `Looks like this might be an issue with ${info.name};\n`
    message += `Please report it at ${info.bugs.url}`
  }

  console.error(message)
}

const handleError = (error) => {
  const code = typeof error.code === 'number' ? (error.code || 1) : 1
  showError(error, true, true)
  process.exit(code)
}

process.on('uncaughtException', handleError)

const argv = process.argv.slice(2)

if ((argv.indexOf('--help') !== -1) || (argv.indexOf('-h') !== -1)) {
  console.log(USAGE)
  process.exit(0)
}

if ((argv.indexOf('--version') !== -1) || (argv.indexOf('-v') !== -1)) {
  console.log(info.version)
  process.exit(0)
}

const getResinSdk = (options) => {
  // Creates a temporary directory for resin sdk so it won't replace any existing token.
  const resinSdkOptions = { apiKey: options.apiKey, apiUrl: options.apiHost }
  return tmp.dirAsync({ unsafeCleanup: true })
  .then((path) => {
    resinSdkOptions.dataDirectory = path
    const resin = resinSdk(resinSdkOptions)
    if (options.apiToken) {
      return resin.token.set(options.apiToken)
      .return(resin)
    }
    return resin
  })
}

const options = {
  appId: process.env['APP_ID'],
  image: process.env['IMAGE'],
  apiToken: process.env['API_TOKEN'],
  apiKey: process.env['API_KEY'],
  commit: process.env['COMMIT'],
  apiHost: process.env['API_HOST'],
  registryHost: process.env['REGISTRY_HOST'],
  splashImage: process.env['SPLASH_IMAGE'],
  dontDetectFlasherTypeImages: process.env['DONT_DETECT_FLASHER_TYPE_IMAGES'],
  dontCheckDeviceType: !!process.env['DONT_CHECK_DEVICE_TYPE']
}

while (argv.length) {
  switch (argv.shift()) {
    case '--app': options.appId = parseInt(argv.shift()); break
    case '--img': options.image = argv.shift(); break
    case '--api-token': options.apiToken = argv.shift(); break
    case '--api-key': options.apiKey = argv.shift(); break
    case '--commit': options.commit = argv.shift(); break
    case '--api-host': options.apiHost = argv.shift(); break
    case '--registry': options.registryHost = argv.shift(); break
    case '--splash-image': options.splashImage = argv.shift(); break
    case '--dont-detect-flasher-type-images': options.dontDetectFlasherTypeImages = true; break
    case '--dont-check-device-type': options.dontCheckDeviceType = true; break
  }
}

// Show usage help if no options have been set
if (!(options.appId && options.image && (options.apiToken || options.apiKey))) {
  console.error(USAGE)
  process.exit(1)
}

console.log('\nBuilding preloader image...\n')
const buildOutputStream = preload.build(docker)

const buildProgress = new visuals.Progress('Building Docker preloader image.')

buildOutputStream.on('progress', (percentage) => {
  buildProgress.update({ percentage })
})

if (process.env.DEBUG) {
  buildOutputStream.pipe(process.stdout)
}

streamToPromise(buildOutputStream)
.then(() => {
  return getResinSdk(options)
})
.then((resin) => {
  return preload.getApplication(resin, options.appId)
  .then((application) => {
    options.application = application

    const slugAndBuilds = preload.getDeviceTypeSlugAndPreloadedBuilds(docker, options)
    const interceptor = new preload.CtrlCInterceptor(slugAndBuilds.cancel)

    interceptor.start()

    return slugAndBuilds.promise
    .tap(() => {
      interceptor.stop()
    })
  })
  .then((data) => {
    if (data === undefined) {
      // getDeviceTypeSlugAndPreloadedBuilds has been cancelled
      process.exit(TERMINATED_BY_CTRL_C)
    }
    if (options.dontCheckDeviceType === false && data.slug !== options.application.device_type) {
      console.error(
        `Application device type (${options.application.device_type}) and image device type (${data.slug}) do not match.`
      )
      process.exit(1)
    }
    const builds = data.builds.map((build) => {
      return build.slice(-preload.BUILD_HASH_LENGTH)
    })
    if (builds.indexOf(options.commit || options.application.commit) !== -1) {
      console.log('This build is already preloaded in this image.')
      process.exit(0)
    }
    console.log('\nPreloading...\n')
    const runInfo = preload.run(process.stdin, resin, docker, options)

    // handle CTRL+C
    const runInterceptor = new preload.CtrlCInterceptor(runInfo.cancel)

    runInfo.output.pipe(process.stdout)

    const fetchSizeProgress = new visuals.Progress(`Fetching container size for ${options.imageRepo}`)
    runInfo.fetchSizeProgress.on('progress', (percentage) => {
      fetchSizeProgress.update({ percentage })
      if (percentage === 100) {
        // When the docker container starts, we want it to
        // finish and be removed. This is why we intercept
        // CTRL+C.
        // Set raw mode to be able to intercept CTRL-C
        runInterceptor.start()
      }
    })

    const dockerPullProgress = new visuals.Progress('Pulling image')
    runInfo.dockerPullProgress.on('progress', (percentage) => {
      dockerPullProgress.update({ percentage })
    })

    return runInfo.statusCodePromise
    .tap(() => {
      runInterceptor.stop()
    })
  })
})
.then((statusCode) => {
  if (statusCode !== 0) {
    process.exit(statusCode)
  }
  console.log('\n[OK] Done.')
})
.catch(handleError)
