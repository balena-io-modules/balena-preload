#!/usr/bin/env node

'use strict'

const Docker = require('dockerode')
const preload = require('..')
const info = require('../package.json')
const Promise = require('bluebird')
const resinSdk = require('resin-sdk')
const tmp = Promise.promisifyAll(require('tmp'))
const visuals = require('resin-cli-visuals')
const nodeCleanup = require('node-cleanup')

const docker = new Docker({Promise})

tmp.setGracefulCleanup()

const USAGE = `
  Usage: ${info.name} [options]

  Options:

    --app            Application ID (required)
    --img            Disk image (or zip file for Edison images) to preload into (required)
    --api-token      API token (required, or api-key)
    --api-key        API key (required, or api-token)
    --commit         Application commit to preload (default: latest)
    --splash-image   PNG Image for custom splash screen

    --dont-detect-flasher-type-images Disables the flasher type images detection: treats all images as non flasher types
    --dont-check-device-type          Disables check for matching device types in image and application

    --help, -h       Display ${info.name} usage
    --version, -v    Display ${info.name} version

  Environment variables:

    RESINRC_RESIN_URL (defaults to resin.io)

    The following option flags can also be set
    via the corresponding environment variables:

    --app                               APP_ID
    --img                               IMAGE
    --api-token                         API_TOKEN
    --api-key                           API_KEY
    --commit                            COMMIT
    --splash-image                      SPLASH_IMAGE
    --dont-detect-flasher-type-images   DONT_DETECT_FLASHER_TYPE_IMAGES
    --dont-check-device-type            DONT_CHECK_DEVICE_TYPE

  Example:

    ${info.name} --app 123456 --api-token "xxxx..." --img /path/to/resin-os.img
`

const inspect = (value) => {
  return require('util').inspect(value, {
    colors: process.stdout.isTTY
  })
}

const showError = (error, details, report) => {
  let message = !details ? `\n[ERROR] ${error.message}` : `\n${inspect(error)}`

  if (report) {
    message += '\n\n'
    message += `Looks like this might be an issue with ${info.name};\n`
    message += `Please report it at ${info.bugs.url}`
  }

  console.error(message)
}

const handleError = (error) => {
  const code = typeof error.code === 'number' ? (error.code || 1) : 1
  showError(error, true, true)
  process.exit(code)
}

process.on('uncaughtException', handleError)

const argv = process.argv.slice(2)

if ((argv.indexOf('--help') !== -1) || (argv.indexOf('-h') !== -1)) {
  console.log(USAGE)
  process.exit(0)
}

if ((argv.indexOf('--version') !== -1) || (argv.indexOf('-v') !== -1)) {
  console.log(info.version)
  process.exit(0)
}

const getResinSdk = (options) => {
  // Creates a temporary directory for resin sdk so it won't replace any existing token.
  const resinSdkOptions = { apiKey: options.apiKey }
  if (process.env.RESINRC_RESIN_URL !== undefined) {
    resinSdkOptions.apiUrl = 'https://api.' + process.env.RESINRC_RESIN_URL  // TODO: this should not be needed
  }
  return tmp.dirAsync({ unsafeCleanup: true })
  .spread((path) => {
    resinSdkOptions.dataDirectory = path
    const resin = resinSdk(resinSdkOptions)
    if (options.apiToken) {
      return resin.token.set(options.apiToken)
      .return(resin)
    }
    return resin
  })
}

const options = {
  appId: process.env['APP_ID'],
  image: process.env['IMAGE'],
  apiToken: process.env['API_TOKEN'],
  apiKey: process.env['API_KEY'],
  commit: process.env['COMMIT'],
  splashImage: process.env['SPLASH_IMAGE'],
  dontCheckDeviceType: !!process.env['DONT_CHECK_DEVICE_TYPE']
}

while (argv.length) {
  switch (argv.shift()) {
    case '--app': options.appId = parseInt(argv.shift()); break
    case '--img': options.image = argv.shift(); break
    case '--api-token': options.apiToken = argv.shift(); break
    case '--api-key': options.apiKey = argv.shift(); break
    case '--commit': options.commit = argv.shift(); break
    case '--splash-image': options.splashImage = argv.shift(); break
    case '--dont-check-device-type': options.dontCheckDeviceType = true; break
  }
}

// Show usage help if no options have been set
if (!(options.appId && options.image && (options.apiToken || options.apiKey))) {
  console.error(USAGE)
  process.exit(1)
}

const progressBars = {}

const progressHandler = (event) => {
  let progressBar = progressBars[event.name]
  if (!progressBar) {
    progressBar = progressBars[event.name] = new visuals.Progress(event.name)
  }
  progressBar.update({ percentage: event.percentage })
}

const spinners = {}

const spinnerHandler = (event) => {
  let spinner = spinners[event.name]
  if (!spinner) {
    spinner = spinners[event.name] = new visuals.Spinner(event.name)
  }
  if (event.action === 'start') {
    spinner.start()
  } else {
    // Output an empty line so the spinner doesn't get erased
    console.log()
    spinner.stop()
  }
}

class ExitError extends (Error) {}

let gotSignal = false

getResinSdk(options)
.then((resin) => {
  const preloader = new preload.Preloader(
    resin,
    docker,
    options.appId,
    options.commit,
    options.image,
    options.splashImage,
    options.proxy
  )

  if (process.env.DEBUG) {
    preloader.stderr.pipe(process.stderr)
  }

  preloader.on('progress', progressHandler)
  preloader.on('spinner', spinnerHandler)

  nodeCleanup((exitCode, signal) => {
    if (signal) {
      gotSignal = true
      nodeCleanup.uninstall()  // don't call cleanup handler again
      preloader.cleanup()
      .then(() => {
        // calling process.exit() won't inform parent process of signal
        process.kill(process.pid, signal)
      })
      return false
    }
  })

  return new Promise((resolve, reject) => {
    preloader.on('error', (err) => {
      reject(err)
    })

    return preloader.build()
    .then(() => {
      return preloader.prepare()
    })
    .then(() => {
      return preloader.fetchApplication()
    })
    .then(() => {
      if (preloader.application.build.length === 0) {
        reject(new ExitError('This application has no successful builds'))
      }
      return preloader.getDeviceTypeAndPreloadedBuilds()
    })
    .then((info) => {
      if (options.dontCheckDeviceType === false && info.device_type !== preloader.application.device_type) {
        const msg = `Application device type (${preloader.application.device_type}) and image device type (${info.device_type}) do not match.`
        reject(new ExitError(msg))
      }
      const builds = info.preloaded_builds.map((build) => {
        return build.slice(-preload.BUILD_HASH_LENGTH)
      })
      if (builds.indexOf(options.commit || preloader.application.commit) !== -1) {
        reject(new ExitError('This build is already preloaded in this image.'))
      }
      return preloader.preload()
      .then(resolve)
    })
    .catch(reject)
  })
  .finally(() => {
    if (!gotSignal) {
      return preloader.cleanup()
    }
  })
})
.catch(ExitError, (err) => {
  console.error('Error:', err.message)
  process.exit(1)
})
.catch(handleError)
